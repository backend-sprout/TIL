# Sentinal 
## Sentinal 개요  
       
**`In-Memory Database`에서의 장애 위험성**.       
레디스 프로세스가 다운되면 메모리 내에 저장됐던 데이터는 유실됩니다.      
복제 노드가 있다면 다행히 그 데이터는 복제 노드에 남아있지만,   
**운영 중인 서비스에서 어플리케이션이 마스터에 연결된 상태였다면 다음 과정을 직접 수행해야 합니다.**  
  
1. 복제 노드에 접속해서 REPLICAOF NO ONE 커맨드를 통해 마스터 연결 해제   
2. 어플리케이션 코드에서 레디스 연결 설정을 변경 (마스터 노드의 IP -> 복제 노드의 IP)
3. 배포
    
실제 운영되는 서비스에서 이를 해결하기까지는 오랜 시간이 걸릴 것이고, 이 기간 동안 데이터가 유실될 수도 있습니다.          
어플리케이션이 마스터 노드에 접근할 수 없을 때 데이터를 가져오기 위해 갑자기 많은 커넥션이 RDBMS에 몰려 서비스 장애로까지 이어진 사례도 많습니다.   
이러한 문제를 해결하기 위해서 Redis 는 Sentinal 기능을 지원해줍니다.    
     
## Sentinal 을 이용한 고가용성      
                  
Redis Sentinel은 Redis Cluster 를 사용하지 않을 때 Redis에 고가용성을 제공합니다.             
Redis Sentinel은 또한 `모니터링`, `알림`과 같은 `기타 부수적 작업`을 제공하고 클라이언트를 위한 구성 제공자 역할을 합니다.  
           
**모니터링** 
* Sentinel은 마스터 및 복제본 인스턴스가 예상대로 작동하는지 지속적으로 확인한다.         

**알림**    
* Sentinel은 API를 통해 모니터링되는 Redis 인스턴스 중 하나에 문제가 있음을 알릴 수 있다.          
  
**자동 장애 조치**   
* 마스터가 예상대로 작동하지 않으면        
* Sentinel은 복제본이 마스터로 승격되고 다른 추가 복제본이 새 마스터를 사용하도록 재구성되고       
* Redis 서버를 사용하는 애플리케이션에 사용할 새 주소에 대해 알리는 장애 조치 프로세스를 시작할 수 있다.   
  
**구성 제공자**  
* Sentinel은 클라이언트 서비스 검색을 위한 권한 소스 역할을 한다.   
* 클라이언트는 주어진 서비스를 담당하는 현재 Redis 마스터의 주소를 요청하기 위해 Sentinels에 연결한다.  
* 장애 조치가 발생하면 Sentinels는 새 주소를 보고한다.  
  

## 분산 시스템으로서의 센티넬

Redis Sentinel은 분산 시스템을 지향합니다.  
Redis Sentinel은 여러 Sentinal 프로세스가 있는 노드들을 하나의 논리적 구성으로 실행되도록 설계되어있습니다.  
  
1. 여러 Sentinal이 마스터를 더 이상 사용할 수 없다는 사실에 동의하면 실패 감지가 수행됩니다.      
2. Sentinel 자체는 모든 Sentinel 프로세스가 작동하지 않는 경우에도 계속 작동하므로 시스템이 장애에 대해 견고합니다.     


## Sentinel 구성
Sentinal의 정상적인 기능을 위해서는 적어도 3개의 Sentinal 인스턴스가 필요합니다.   
각 Sentinal 인스턴스는 Redis의 모든 노드를 감시하며 서로 연결되어 있습니다.      
세 대의 Sentinel 노드 중 과반수 이상(quorum)이 동의해야만 페일오버를 시작할 수 있습니다.(홀수 이유)  

![4(4)](https://user-images.githubusercontent.com/50267433/196723347-887b0e66-8821-4e0e-960f-f2a4d0d06393.png)

  
어플리케이션은 마스터나 복제 노드에 직접 연결하지 않고, Sentinel 노드와 연결합니다.      
Sentinel 노드는 어플리케이션에게 현재 마스터의 IP, PORT를 알려주며, 페일오버 이후에는 새로운 마스터의 IP, PORT 정보를 알려줍니다.   

### Failover 과정
 
![5(4)](https://user-images.githubusercontent.com/50267433/196729690-03444555-4530-40f3-8421-d1a18136a3d5.png)

  
마스터에 두 개의 복제 노드가 연결되어 있다고 가정해보겠습니다.     
이때 마스터가 다운되면 이를 감시하고 있던 Sentinel은 마스터에 진짜 연결할 수 없는지에 대한 투표를 시작합니다.   

![6(4)](https://user-images.githubusercontent.com/50267433/196729775-9b7ec16d-c6dd-4111-a766-f97879b3db55.png)
   
이 투표에서 과반수 이상이 동의하면 페일오버를 시작합니다.         
과반수 이상이기에 위 예시에서는 세 개 중 두 개 노드의 찬성을 얻어 페일오버가 가능합니다.         
  
연결이 안되는 마스터에 대한 복제 연결을 끊고, 복제 노드 중 한 개를 선택하여 마스터로 승격시킵니다.        
또 다른 복제 노드는 승격된 마스터 노드에 연결시킵니다.      
만약 다운되었던 마스터 노드가 다시 살아난다면 새로운 마스터에 복제본으로 연결됩니다.  



  



