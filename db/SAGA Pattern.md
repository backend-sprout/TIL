# Saga Pattern
SAGA 패턴이란, 
마이크로서비스들끼리 이벤트를 주고받아 
마이크로서비스에서의 작업이 실패하면 
이전까지의 작업이 완료된 마이크로 서비스들에게 
보상 이벤트를 소싱함으로써 분산환경에서 원자성을 보장하는 패턴이다.  

## 성공시

![[102894284-33d83780-44a6-11eb-9cb0-1c526edd5642.png]]


## 실패시
![[102894291-35a1fb00-44a6-11eb-93bf-2371f322c99c.png]]

SAGA 패턴의 핵심은 **트랜잭션 관리 주체가 DBMS가 아닌, Application 에 있다.**  
Application 이 분산되어 있을 때는 각 Application 하위에 존재하는 DB는 Local Transaction만 담당한다.

즉, 각각의 Application 의 트랜잭션 요청의 실패로 인한 Rollback 처리는 Application 에서 구현한다.

순차적으로 트랜잭션이 처리되며,
마지막 트랜잭션이 끝났을 때 데이터가 완전히 영속되었음을 확인하고 종료한다.
이 방법을 통해서 최종 일관성 (Eventually Consistency) 를 달성할 수 있다. 

## SAGA 패턴의 종류
일반적으로 SAGA 패턴은 2가지로 나뉜다.  
1. Choreography based SAGA Pattern
2. Orchestration based SAGA Pattern

### Choreography based SAGA pattern

![[Pasted image 20221004033506.png]]
Choreography-based Saga 패턴은 
보유한 서비스내의 Local Transaction 을 관리하며  
트랜잭션이 종료하게 되면 완료 Event를 발행한다.   

만약 그 다음 수행할 트랜잭션이 있으면 
해당 트랜잭션을 수행해야하는 App 으로 이벤트를 보내고
해당 APP은 완료 Event 를 수신받고 다음 작업을 진행한다.  
그리고 이를 순차적으로 수행한다.   
이때 Event 는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달 할 수 있다. 


![[102895310-cf1ddc80-44a7-11eb-9941-de72656dd3a8.png]]
Choreography-base Saga 패턴에서는   
각 App별로 트랜잭션을 관리하는 로직이 있다. 
이를 통해서 중간에 트랜잭션이 실패하면 
해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도한다.  
즉, 실패가 발생하면 실패와 관련된 이벤트를 발행하여 Roolback 을 처리하도록 한다.(delete/update 등)


### Orchestration based SAGA pattern
Orchestration-Based Saga 패턴은 
트랜잭션 처리를 위해 Saga Manager 인스턴스가 별도로 존재한다.   
트랜잭션에 관여하는 모든 APP은 Manager 에 의해 점진적으로 트랜잭션을 수행하며   
결과를 Manager에게 전달하게 되고, 비즈니스로직상 마지막 트랜잭션이 끝나면   
Manager를 종료해서 전체 트랜잭션 처리를 종료한다.   
만약 중간에 실패하게 되면 Manager 에서 보상 트랜잭션을 발동하여 일관성을 유지한다. 

![[102895323-d47b2700-44a7-11eb-9bc1-2c46cf517c06.png]]


즉, 이벤트 발행 주체가 Manager 라는 뜻이다.  
해당 Orchestration-Based Saga 패턴은 모든 관리를 Manager가 호출하기 때문에    
분산트랜잭션의 중앙 집중화가 이루어집니다.     




# 추가적인 내용

### 결론

  

앞으로 샤딩된 시스템에서 2PC를 계속 사용하는 시스템 설계자의 이점은 거의 없습니다. 저는 시스템 유발 중단을 제거하고 상태 유발 중단을 다시 작성하는 것이 더 나은 방법이라고 믿습니다. [Calvin 또는 FaunaDB](https://fauna.com/) 와 같은 결정적 데이터베이스 시스템[](https://fauna.com/) 어쨌든 시스템 유발 중단을 항상 제거하므로 일반적으로 위에서 설명한 대로 2PC를 피할 수 있습니다. 그러나 이러한 이점을 결정적 데이터베이스에만 국한하는 것은 큰 낭비입니다. 비결정적 시스템에서 시스템 유발 중단을 제거하는 것은 어렵지 않습니다. 최근 프로젝트는 비관적 동시성 제어 이외의 동시성 제어 기술을 사용하는 시스템에서 시스템 유발 중단을 제거하는 것이 가능하다는 것을 보여주었습니다. 예를 들어, 위에서 링크한 PVW와 지연 트랜잭션 처리 시스템 모두 다중 버전 동시성 제어의 변형을 사용합니다. 그리고 FaunaDB는 낙관적 동시성 제어의 변형을 사용합니다.

  

제 생각에는 시스템에서 시스템 유발 중단의 필요성에 대한 구식 가정을 계속할 변명의 여지가 거의 없습니다. 시스템이 단일 시스템에서 실행되던 옛날에는 그러한 가정이 정당했습니다. 그러나 많은 시스템이 서로 독립적으로 실패할 수 있는 여러 시스템으로 확장되어야 하는 현대에 이러한 가정에는 2PC와 같은 값비싼 조정 및 커밋 프로토콜이 필요합니다. 2PC의 성능 문제는 더 나은 확장성, 가용성 및 성능을 달성하기 위해 중요한 보증을 포기하는 비 ACID 호환 시스템의 부상의 주요 원인이었습니다. 2PC는 너무 느립니다 --- 모든 트랜잭션의 대기 시간을 증가시킵니다 --- 프로토콜 자체의 길이뿐만 아니라 동일한 데이터 세트에 액세스하는 트랜잭션이 동시에 실행되는 것을 방지합니다. 2PC는 또한 확장성(동시성을 줄임으로써)과 가용성(위에서 논의한 차단 문제)을 제한합니다. 앞으로 나아갈 길은 분명합니다. 시스템을 설계할 때 구식 가정을 재고하고 2단계 커밋에 "안녕"이라고 말해야 합니다!
